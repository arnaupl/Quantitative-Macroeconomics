    # -*- coding: utf-8 -*-
"""
Created on Sun Nov 22 19:42:51 2020

@author: Arnau Pagès López


In this section I extend the usual representative agent neoclassical growth model 
by adding a third production factor which is labor from home, and a productivity and 
welfare shock $i$ which is the infection rate. What I do in this section is to try to
 simulate what happened in March/April (depending on the country) when ,suddenly, the
 Covid-19 outbreak appeared generating an unexpected shock that made the economy to 
 fall towards a new "Covid steady state". My aim here is to study the transition from
 the pre-covid economy to the covid economy. Specifically, the element in which 
 I'm mostly interested is in how is the transition path for labor at workplace
 and labor at home.
 
 
 WARNING: As in Step 3.1, I use brute force value function iteration, the code 
 takes near 5 minutes to run. Sorry about this.
"""
print('As in Step 3.1, I use brute force value function iteration, the code takes near 5 minutes to run. But it works! Sorry about this.')
import math
from scipy.optimize import fsolve
import numpy as np
import matplotlib.pyplot as plt
import quantecon as qe


#Define parameter values.

beta=0.7     #Discount factor
delta=0.4    #Rate of depreciation
alpha=0.675  #Labor share in Cobb-Douglas production function
A_w=1.6      #TFP associated to labor at workplace
A_h=0.7      #TFP associated to labor from home
i1=0         #Infection rate pre-covid.
i2=0.2       #Infection rate covid.
rho=1.1      #Elasticity of substitution
phi=0.7      #Productivity loss associated with teleworking.
omega=5      #Omega and nu are parameters associated with the disutility of labor.
nu=2.3
q=15          #Factor augmenting the disutility of working at workplace if the infection rate is positive
z=(rho-1)/rho #Substitution parameter


#Define some functions that I'm going to use to compute the steady state values of the different variables.
def ht_h(ht_w):
    return 1-ht_w

def output_pre(kt,ht_w,ht_h):
    return kt**(1-alpha)*(((A_w-i1)*ht_w**(z)+phi*A_h*ht_h**(z))**(1/z))**alpha  

def output_cov(kt,ht_w,ht_h):
    return kt**(1-alpha)*(((A_w-i2)*ht_w**(z)+phi*A_h*ht_h**(z))**(1/z))**alpha  
                            
def investment(kt,kt1):
    return kt1-(1-delta)*kt

def consumption_pre(kt,kt1,ht_w,ht_h):
    return output_pre(kt,ht_w,ht_h)- investment(kt,kt1)

def consumption_cov(kt,kt1,ht_w,ht_h):
    return output_cov(kt,ht_w,ht_h)- investment(kt,kt1)

def welfare_pre(ct,ht_w,ht_h):
    return math.log(ct)-(omega+q*i1)*((ht_w**(1+1/nu))/(1+1/nu))-omega*((ht_h**(1+1/nu))/(1+1/nu))

def welfare_cov(ct,ht_w,ht_h):
    return math.log(ct)-(omega+q*i2)*((ht_w**(1+1/nu))/(1+1/nu))-omega*((ht_h**(1+1/nu))/(1+1/nu))    
       


#STEP 1: COMPUTE THE STEADY STATE PRECOVID.
#Solve the system of non-linear equations generated by equations (24) and (25) 
#in the answers PDF evaluated at the steady state and under i=i1.
def steadystate_PREcovid(vars):
    kss_pre,h_wss_pre=vars
    eq1=beta*(1-delta+(1-alpha)*kss_pre**(-alpha)*(((A_w-i1)*h_wss_pre**(z)+phi*A_h*(1-h_wss_pre)**(z))**(1/z))**(alpha))-1
    eq2=(1/(kss_pre**(1-alpha)*(((A_w-i1)*h_wss_pre**(z)+phi*A_h*(1-h_wss_pre)**(z))**(1/z))**(alpha)-delta*kss_pre))*(((alpha*kss_pre**(1-alpha)*((A_w-i1)*z*h_wss_pre**(z-1)-A_h*phi*z*(1-h_wss_pre)**(z-1)))*((((A_w-i1)*h_wss_pre**(z)+phi*A_h*(1-h_wss_pre)**(z))**(1/z))**(alpha)))/(z*((A_w-i1)*h_wss_pre**(z)+phi*A_h*(1-h_wss_pre)**(z))))-(omega+q*i1)*h_wss_pre**(1/nu)+omega*(1-h_wss_pre)**(1/nu)
    return [eq1, eq2]

kss_pre,h_wss_pre=fsolve(steadystate_PREcovid,(0.5,0.5)) #initial values

h_hss_pre=ht_h(h_wss_pre)

yss_pre=output_pre(kss_pre, h_wss_pre, h_hss_pre)

invss_pre=investment(kss_pre,kss_pre)

consss_pre=consumption_pre(kss_pre,kss_pre,h_wss_pre,h_hss_pre)

welfare_measuress_pre=welfare_pre(consss_pre,h_wss_pre,h_hss_pre)


#STEP 2: COMPUTE THE COVID STEADY STATE
#Solve the system of non-linear equations generated by equations (24) and (25) 
#in the answers PDF evaluated at the steady state and under i=i2.
def steadystate_covid(vars):
    kss_cov,h_wss_cov=vars
    eq1=beta*(1-delta+(1-alpha)*kss_cov**(-alpha)*(((A_w-i2)*h_wss_cov**(z)+phi*A_h*(1-h_wss_cov)**(z))**(1/z))**(alpha))-1
    eq2=(1/(kss_cov**(1-alpha)*(((A_w-i2)*h_wss_cov**(z)+phi*A_h*(1-h_wss_cov)**(z))**(1/z))**(alpha)-delta*kss_cov))*(((alpha*kss_cov**(1-alpha)*((A_w-i2)*z*h_wss_cov**(z-1)-A_h*phi*z*(1-h_wss_cov)**(z-1)))*((((A_w-i2)*h_wss_cov**(z)+phi*A_h*(1-h_wss_cov)**(z))**(1/z))**(alpha)))/(z*((A_w-i2)*h_wss_cov**(z)+phi*A_h*(1-h_wss_cov)**(z))))-(omega+q*i2)*h_wss_cov**(1/nu)+omega*(1-h_wss_cov)**(1/nu)
    return [eq1, eq2]

kss_cov,h_wss_cov=fsolve(steadystate_covid,(0.5,0.5)) #initial values

h_hss_cov=ht_h(h_wss_cov)

yss_cov=output_cov(kss_cov, h_wss_cov, h_hss_cov)

invss_cov=investment(kss_cov,kss_cov)

consss_cov=consumption_cov(kss_cov,kss_cov,h_wss_cov,h_hss_cov)

welfare_measuress_cov=welfare_cov(consss_cov,h_wss_cov,h_hss_cov)

#STEP 3:COMPUTE THE TRANSITION.

#Step 3.1: Solve the recursive formulation of the problem under Covid setting 
#(i=i2). I use brute force value function iteration. It takes 5 minutes appoximatelly 
#to run!!

tol_error = 0.001   #tolerance
itera_max = 100000  #maximum number of iterations.

#For convenience redefine prod funcion
def y_cov(k,h_w):
    return k**(1-alpha)*(((A_w-i2)*h_w**(z)+phi*A_h*(1-h_w)**(z))**(1/z))**alpha  


def u_cov(c, h_w):
    if c<1e-2:
        return -1e16      
    else:
        return  np.log(c)-(omega+q*i2)*((h_w**(1+1/nu))/(1+1/nu))-omega*(((1-h_w)**(1+1/nu))/(1+1/nu))

#Grids
#Populate more the intermediate areas because is where we are going to work in the transitions.

nk_low=10
low_kgrid=np.linspace(0.5*kss_cov,0.89*kss_cov,nk_low)

nk_medium=130
medium_kgrid=np.linspace(0.9*kss_cov,1.09*kss_pre,nk_medium)

nk_high=10
high_kgrid=np.linspace(1.1*kss_pre,1.5*kss_pre,nk_high)

nk=nk_low+nk_medium+nk_high


nh_wlow=10
low_h_wgrid=np.linspace(0.01,0.19,nh_wlow)

nh_wmedium=130
medium_h_wgrid=np.linspace(0.2,0.79,nh_wmedium)

nh_whigh=10
high_h_wgrid=np.linspace(0.8,0.99,nh_whigh)

nh_w=nh_wlow+nh_wmedium+nh_whigh

kgrid = np.concatenate((low_kgrid,medium_kgrid,high_kgrid),axis=0)
h_wgrid = np.concatenate((low_h_wgrid,medium_h_wgrid,high_h_wgrid),axis=0)


# Initial guess for value function
vguess = np.zeros((nk))
 

#Empty policy functions to fill
policy_k = np.zeros((nk))
policy_h_w = np.zeros((nk))
policy_cons = np.zeros((nk))
follow_V = np.zeros((nk))


# Empty Return matrix to fill
M = np.zeros((nk,nk,nh_w))  
#Vectorize to make the code run faster
u_cov_vect = np.vectorize(u_cov)   

#Set up Bellman equation.
def bellman_operator(V,return_policies=False):
    for ik, k in enumerate(kgrid):  
        for igh, gh in enumerate(h_wgrid):   
            #Fill return matrix
            M[ik,:,igh] =  u_cov_vect((y_cov(k,gh) +(1-delta)*k - kgrid),gh) +beta*V
            
        follow_V[ik] = np.nanmax(M[ik,:,:])        
        policy_k[ik] = kgrid[np.unravel_index(np.argmax(M[ik,:,:], axis=None), M[ik,:,:].shape)[0]]  
        policy_h_w[ik] = h_wgrid[np.unravel_index(np.nanargmax(M[ik,:,:], axis=None), M[ik,:,:].shape)[1]]  
        policy_cons[ik] =  y_cov(k,policy_h_w[ik]) +(1-delta)*k - policy_k[ik]          
    if return_policies==True:
        return follow_V, policy_k, policy_h_w, policy_cons
    else:
        return follow_V 
    
#Compute fixed point.
qe.tic()
V = qe.compute_fixed_point(bellman_operator, vguess, max_iter=itera_max, error_tol=tol_error, print_skip=20)
#Get the policies
follow_V, g_k, g_h_w, g_c = bellman_operator(V, return_policies=True)
g_h_h=np.ones(nk)-g_h_w
qe.toc()    
    
#Plot value function and policy functions.
  
fig, ax = plt.subplots()
ax.plot(kgrid,V,'.', label='V(k)',color='purple')
ax.set_title('Value function under Covid (i=i2)')
ax.set_ylabel('V')
ax.set_xlabel('k')
plt.show()

fig, ax = plt.subplots()
ax.plot(kgrid,g_h_w,'.', label='gh_w(k)',color='purple')
ax.set_title('Policy function labor at workplace under Covid (i=i2)')
ax.set_ylabel('h_w')
ax.set_xlabel('k')
ax.legend()
plt.show()


fig, ax = plt.subplots()
ax.plot(kgrid,g_h_h,'.', label='gh_h(k)',color='purple')
ax.set_title('Policy function labor from home under Covid (i=i2)')
ax.set_ylabel('h_h')
ax.set_xlabel('k')
ax.legend()
plt.show()



fig, ax = plt.subplots()
ax.plot(kgrid,g_c, '.', label='gc(k)',color='purple')
ax.set_title('Policy function consumption under Covid (i=i2)')
ax.set_ylabel('c')
ax.set_xlabel('k')
ax.legend()
plt.show()


fig, ax = plt.subplots()
ax.plot(kgrid,g_k,'.', label='gk´(k)',color='purple')
ax.set_ylabel('k´')
ax.set_xlabel('k')
ax.set_title('Policy function capital under Covid (i=i2)')
ax.legend()
plt.show()   
    


#Step 3.2
#Regress using OLS, the policies for capital, labor at workplace and labor at home
#on the grid of capital. This will allow to approximate the transitions in a continuous 
#way.
one=np.ones(nk)
X=np.transpose(np.vstack((one,kgrid)))

betas_k=np.dot(np.dot(np.linalg.inv(np.dot(np.transpose(X),X)),np.transpose(X)),g_k)

betas_g_h_w=np.dot(np.dot(np.linalg.inv(np.dot(np.transpose(X),X)),np.transpose(X)),g_h_w)

betas_g_h_h=np.dot(np.dot(np.linalg.inv(np.dot(np.transpose(X),X)),np.transpose(X)),g_h_h)

#This is just to plot the regression line in the scatter plot as I show in Figures 14,15,16 in answers PDF.
gk_Ols=betas_k[0]+betas_k[1]*kgrid
ghw_Ols=betas_g_h_w[0]+betas_g_h_w[1]*kgrid
ghh_Ols=betas_g_h_h[0]+betas_g_h_h[1]*kgrid


fig, ax = plt.subplots()
ax.plot(kgrid,g_k,'.',color='green',label='gk´(k) points')
ax.plot(kgrid,gk_Ols,'-',color='red',label='Regression line')
ax.set_title('Regression for capital stock')
ax.set_ylabel('k´')
ax.set_xlabel('k')
ax.legend(loc='upper left')
plt.show()


ig, ax = plt.subplots()
ax.plot(kgrid,g_h_w,'.',color='green',label='gh_w(k) points')
ax.plot(kgrid,ghw_Ols,'-',color='red',label='Regression line')
ax.set_title('Regression for labor at workplace')
ax.set_ylabel('h_w')
ax.set_xlabel('k')
ax.legend(loc='upper left')
plt.show()


ig, ax = plt.subplots()
ax.plot(kgrid,g_h_h,'.',color='green',label='gh_h(k) points')
ax.plot(kgrid,ghh_Ols,'-',color='red',label='Regression line')
ax.set_title('Regression for labor from home')
ax.set_ylabel('h_h')
ax.set_xlabel('k')
ax.legend(loc='upper left')
plt.show()



#Step 3.3. Use the regression coefficients to compute the transitions.


T=50
trans_pathk=np.zeros((T,1))
trans_pathk[0]=kss_pre
trans_pathk[1]=kss_pre
trans_pathk[2]=kss_pre
for i in range (2,T-1):
    trans_pathk[i+1]=betas_k[0]+betas_k[1]*trans_pathk[i]
    
trans_pathh_w=np.zeros((T,1))
trans_pathh_w[0]=h_wss_pre
trans_pathh_w[1]=h_wss_pre
trans_pathh_w[2]=h_wss_pre
for i in range (2,T-1):
    trans_pathh_w[i+1]=betas_g_h_w[0]+betas_g_h_w[1]*trans_pathh_w[i]
    
    

trans_pathh_h=np.zeros((T,1))
trans_pathh_h[0]=h_hss_pre
trans_pathh_h[1]=h_hss_pre
trans_pathh_h[2]=h_hss_pre
for i in range (2,T-1):
    trans_pathh_h[i+1]=betas_g_h_h[0]+betas_g_h_h[1]*trans_pathh_h[i]
    
    

trans_pathinv=np.zeros((T,1))
trans_pathinv[0]=invss_pre
trans_pathinv[1]=invss_pre
trans_pathinv[2]=invss_pre    
for i in range (3,T-1):
    trans_pathinv[i]=investment(trans_pathk[i],trans_pathk[i+1])
trans_pathinv[T-1]=trans_pathinv[T-2]
    
    

trans_pathoutput=np.zeros((T,1))
trans_pathoutput[0]=yss_pre
trans_pathoutput[1]=yss_pre
trans_pathoutput[2]=yss_pre   
for i in range (3,T-1):
       trans_pathoutput[i]=output_cov(trans_pathk[i],trans_pathh_w[i],trans_pathh_h[i])
trans_pathoutput[T-1]=trans_pathoutput[T-2]    
    
    
trans_pathcons=trans_pathoutput-trans_pathinv    
    
    
trans_pathwelfare_measure=np.zeros((T,1))   
trans_pathwelfare_measure[0]=welfare_measuress_pre   
trans_pathwelfare_measure[1]=welfare_measuress_pre      
trans_pathwelfare_measure[2]=welfare_measuress_pre  
for i in range (3,T-1):
    trans_pathwelfare_measure[i]=welfare_cov(trans_pathcons[i],trans_pathh_w[i],trans_pathh_h[i])
    


time=np.array(list(range(0,(T-29))))


#Plot the transition paths.

fig,ax = plt.subplots()    
ax.plot(time, trans_pathk[0:T-29],':go', color='purple', linewidth=0.5)   
ax.set_title('Transition path for capital')
ax.set_ylabel('Capital stock')
ax.set_xlabel('Time')
ax.set_xticks(time)
ax.set_yticks(np.linspace(kss_cov-50,kss_pre+50,10))
plt.show()


fig,ax = plt.subplots()    
ax.plot(time, trans_pathh_w[0:T-29],':go', color='red', linewidth=0.5)  
ax.plot(time, trans_pathh_h[0:T-29],':go', color='green', linewidth=0.5)  
ax.set_title('Transition path for labor at worplace and from home')
ax.set_ylabel('h_w, h_h')
ax.set_xlabel('Time')
ax.legend(["Trans. path labor at workplace", "Trans. path labor from home"],loc='center right')
ax.set_xticks(time)
ax.set_yticks(np.linspace(0.35,0.65,10),2)
plt.show()


fig,ax = plt.subplots()    
ax.plot(time, trans_pathinv[0:T-29],':go', color='purple', linewidth=0.5)   
ax.set_title('Transition path for investment (equivalently savings)')
ax.set_ylabel('Investment (equivalently savings)')
ax.set_xlabel('Time')
ax.set_xticks(time)
ax.set_yticks(np.linspace(invss_cov-40,invss_pre+40,10))
plt.show()


fig,ax = plt.subplots()    
ax.plot(time, trans_pathoutput[0:T-29],':go', color='purple', linewidth=0.5)   
ax.set_title('Transition path for output')
ax.set_ylabel('Output')
ax.set_xlabel('Time')
ax.set_xticks(time)
ax.set_yticks(np.linspace(yss_cov-100,yss_pre+100,10))
plt.show()


fig,ax = plt.subplots()    
ax.plot(time, trans_pathcons[0:T-29],':go', color='purple', linewidth=0.5)   
ax.set_title('Transition path for consumption')
ax.set_ylabel('Consumption')
ax.set_xlabel('Time')
ax.set_xticks(time)
ax.set_yticks(np.linspace(consss_cov-100,consss_pre+100,10))
plt.show()


fig,ax = plt.subplots()    
ax.plot(time, trans_pathwelfare_measure[0:T-29],':go', color='purple', linewidth=0.5)   
ax.set_title('Transition path for instantaneous welfare')
ax.set_ylabel('Instantaneous welfare')
ax.set_xlabel('Time')
ax.set_xticks(time)
ax.set_yticks(np.linspace(welfare_measuress_cov-5,welfare_measuress_pre+5,10))
plt.show()


    
    
    
    
    







